= Persist your data in Kubernetes

== Learning Outcomes
After completing the lab, you will be able to:

 . Persist your data to Mysql  database running in Kubernetes
 . Create persistent volumes for MySQL 
. Create persistent volumes & persistent volume claim for MySQL
. Create secret to store MySQL credentials.

 
Before starting the lab, pull in the persistence-start task.
   
   git checkout -b persistence-work

As part of the persistence-start checkout you would get one test class for which you need to add the necessary code to make the test cases pass.
   
== Follow the below instructions to reach to the solution.

.   Create new Java class  Page.java under org.dell.kube.pages
 

+
[source,java]
---------------------------------------------------------------------
package org.dell.kube.pages;

public class Page {

    private Long id;
    private String businessName;
    private Long categoryId;
    private String address;
    private String contactNumber;

    public Page(){}

    public Page(String businessName, String address, long categoryId, String contactNumber) {
        this.businessName = businessName;
        this.address = address;
        this.categoryId = categoryId;
        this.contactNumber = contactNumber;
    }

    public Page(long id, String businessName, String address, long categoryId, String contactNumber) {
        this.id = id;
        this.businessName = businessName;
        this.address = address;
        this.categoryId = categoryId;
        this.contactNumber = contactNumber;
    }
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getBusinessName() {
        return businessName;
    }

    public void setBusinessName(String businessName) {
        this.businessName = businessName;
    }

    public Long getCategoryId() {
        return categoryId;
    }

    public void setCategoryId(Long categoryId) {
        this.categoryId = categoryId;
    }

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    public String getContactNumber() {
        return contactNumber;
    }

    public void setContactNumber(String contactNumber) {
        this.contactNumber = contactNumber;
    }
}
---------------------------------------------------------------------

.   Create new Java class  IPageRepository.java under org.dell.kube.pages


+
[source, java, numbered]
---------------------------------------------------------------------
package org.dell.kube.pages;

import java.util.List;

public interface IPageRepository {
    public Page create(Page page);
    public Page read(long id);
    public List<Page> list();
    public Page update(Page page, long id);
    public void delete(long id);
}
---------------------------------------------------------------------

. Create a PageController.java in src folder. Create an Instance of IPageRepository and initialize  it with a constructor injection
+ 
[source,java]
---------------------------------------------------------------------
package org.dell.kube.pages;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/pages")
public class PageController {

    private IPageRepository pageRepository;
    public PageController(IPageRepository pageRepository)
    {
        this.pageRepository = pageRepository;
    }
    @PostMapping
    public ResponseEntity<Page> create(@RequestBody Page page) {
        Page newPage= pageRepository.create(page);
        return new ResponseEntity<Page>(newPage, HttpStatus.CREATED);
    }
    @GetMapping("{id}")
    public ResponseEntity<Page> read(@PathVariable long id) {
        Page page = pageRepository.read(id);
        if(page!=null)
            return new ResponseEntity<Page>(page,HttpStatus.OK);
        else
            return new ResponseEntity(HttpStatus.NOT_FOUND);
    }
    @GetMapping
    public ResponseEntity<List<Page>> list() {
        List<Page> pages= pageRepository.list();
        return new ResponseEntity<List<Page>>(pages,HttpStatus.OK);
    }
    @PutMapping("{id}")
    public ResponseEntity<Page> update(@RequestBody Page page, @PathVariable long id) {
        Page updatedPage= pageRepository.update(page,id);
        if(updatedPage!=null)
            return new ResponseEntity<Page>(updatedPage,HttpStatus.OK);
        else
            return new ResponseEntity(HttpStatus.NOT_FOUND);
    }
    @DeleteMapping("{id}")
    public ResponseEntity delete(@PathVariable long id) {
        pageRepository.delete(id);
        return new ResponseEntity(HttpStatus.NO_CONTENT);
    }
}
---------------------------------------------------------------------

.   Here we will use JDBC for data persistence. Add jpa and mysql connector dependencies in build.gradle. It will fetch the Spring JDBC library.
 

+
[source,java]
---------------------------------------------------------------------
implementation 'org.springframework.boot:spring-boot-starter-jdbc'
implementation 'mysql:mysql-connector-java:8.0.12'
---------------------------------------------------------------------

.   Add the following line in test.environment closure of build.gradle


+
[source, java, numbered]
---------------------------------------------------------------------
test.environment([
		"PAGE_CONTENT": "YellowPages",
		"SPRING_DATASOURCE_URL": "jdbc:mysql://localhost:3306/pages?createDatabaseIfNotExist=true&useSSL=false",
    "SPRING_DATASOURCE_USERNAME": "root",
    "SPRING_DATASOURCE_PASSWORD": "test123",
])
---------------------------------------------------------------------

.   Add the junit dependency in depenendency closure in build.gradle


+
[source, java, numbered]
---------------------------------------------------------------------
testImplementation "junit:junit:4.12"
---------------------------------------------------------------------



. Add jdbc related properties in application.properties for both main and test folders

+ 
[source,java]
---------------------------------------------------------------------
spring.datasource.url=jdbc:mysql://localhost:3306/pages?createDatabaseIfNotExist=true&useSSL=false
spring.datasource.username=root
spring.datasource.password=test123
---------------------------------------------------------------------

. Add new class MySqlPageRepository.java which implements IPageRepository.

+ 
[source,java]
---------------------------------------------------------------------
package org.dell.kube.pages;

import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.ResultSetExtractor;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.stereotype.Repository;

import javax.sql.DataSource;
import java.sql.PreparedStatement;
import java.util.List;

import static java.sql.Statement.RETURN_GENERATED_KEYS;


public class MySqlPageRepository implements IPageRepository {
    private final JdbcTemplate jdbcTemplate;
    public MySqlPageRepository(DataSource dataSource)
    {
        this.jdbcTemplate=new JdbcTemplate(dataSource);
        this.init();
    }
    @Override
    public Page create(Page page) {
        KeyHolder generatedKeyHolder = new GeneratedKeyHolder();

        jdbcTemplate.update(connection -> {
            PreparedStatement statement = connection.prepareStatement(
                    "INSERT INTO pages (business_name, address, category_id, contact_number) " +
                            "VALUES (?, ?, ?, ?)",
                    RETURN_GENERATED_KEYS
            );
            statement.setString(1, page.getBusinessName());
            statement.setString(2, page.getAddress());
            statement.setLong(3,page.getCategoryId());
            statement.setString(4,page.getContactNumber());

            return statement;
        }, generatedKeyHolder);

        return read(generatedKeyHolder.getKey().longValue());

    }
    @Override
    public Page read(long id) {
        return jdbcTemplate.query(
                "SELECT id, business_name, address, category_id, contact_number FROM pages WHERE id = ?",
                new Object[]{id},
                extractor);
    }

    @Override
    public List<Page> list() {
        return jdbcTemplate.query("SELECT id, business_name, address, category_id, contact_number FROM pages", mapper);
    }

    @Override
    public Page update(Page page, long id) {
        jdbcTemplate.update("UPDATE pages " +
                        "SET business_name = ?, address = ?, category_id = ?,  contact_number = ? " +
                        "WHERE id = ?",
                page.getBusinessName(),
                page.getAddress(),
                page.getCategoryId(),
                page.getContactNumber(),
                id);

        return read(id);
    }

    @Override
    public void delete(long id) {
        jdbcTemplate.update("DELETE FROM pages WHERE id = ?", id);
    }

    private final RowMapper<Page> mapper = (rs, rowNum) -> new Page(
            rs.getLong("id"),
            rs.getString("business_name"),
            rs.getString("address"),
            rs.getLong("category_id"),
            rs.getString("contact_number")
    );
    private final ResultSetExtractor<Page> extractor =
            (rs) -> rs.next() ? mapper.mapRow(rs, 1) : null;

    private void init(){
        jdbcTemplate.execute("create table if not exists pages(\n" +
                "  id bigint(20) not null auto_increment,\n" +
                "  business_name VARCHAR(50),\n" +
                "  address VARCHAR(50),\n" +
                "  category_id bigint(20),\n" +
                "  contact_number VARCHAR(50),\n" +
                "\n" +
                "  primary key (id)\n" +
                ")\n" +
                "engine = innodb\n" +
                "default charset = utf8;");
    }
}
---------------------------------------------------------------------


. Make change in PageApplication class to return MySqlPageRepository instance. This method would also take a DataSource instance as argument.

+

[source,java]
---------------------------------------------------------------------
@Bean
public IPageRepository iPageRepository(DataSource dataSource){
		return new MySqlPageRepository(dataSource);
}
---------------------------------------------------------------------


. Add new deployment file mysql-pv.yaml to be used by the new mysql deployment volume in kubernetes cluster under deployment folder
+

[source,java]
---------------------------------------------------------------------
apiVersion: v1
kind: PersistentVolume
metadata:
  name: mysql-volume-<your-name>
  namespace: <your-name>
  labels:
    type: local
spec:
  storageClassName: mysql-<your-name>
  capacity:
    storage: 1Gi
  accessModes:
    - ReadWriteMany
  hostPath:
    path: "/mnt/data-<your-name>"
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-volume-claim-<your-name>
  namespace: <your-name>
spec:
  storageClassName: mysql-<your-name>
  accessModes:
    - ReadWriteMany
  resources:
    requests:
      storage: 1Gi
---------------------------------------------------------------------

. Create a new file called mysql-secret.yaml in deployment folder or create using the command below.

    kubectl create secret generic mysql-secret --from-literal=mysql-pass='test123' -n <your-name>
+

[source,java]
---------------------------------------------------------------------
apiVersion: v1
data:
  mysql-pass: test123
kind: Secret
metadata:
  name: mysql-secret
  namespace: <your-name>
---------------------------------------------------------------------

. Create a new file called mysql-deployment.yaml in deployment folder
+

[source,java]
---------------------------------------------------------------------
apiVersion: apps/v1 
kind: Deployment
metadata:
  name: mysql
  namespace: <your-name>
spec:
  replicas: 1
  selector:
    matchLabels:
      app: mysql
  strategy:
    type: Recreate
  template:
    namespace : <your-name>
    metadata:
      labels:
        app: mysql
    spec:
      containers:
        - image: mysql:8.0
          name: mysql
          env:
            # Instead of using value directly we could also use secrets
           - name: MYSQL_ROOT_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: mysql-secret
                  key: mysql-pass
          ports:
            - containerPort: 3306
              name: mysql
          volumeMounts:
            - name: mysql-storage
              mountPath: "/var/lib/mysql-<your-name>"
      volumes:
        - name: mysql-storage
          persistentVolumeClaim:
            claimName: mysql-volume-claim-<your-name>
---
apiVersion: v1
kind: Service
metadata:
  name: mysql
  namespace: <your-name>
spec:
  ports:
    - port: 3306
  selector:
    app: mysql
  clusterIP: None
---------------------------------------------------------------------

. Replace all the <your-name> with your actual first name.
. Ensure that a MySQL instance with password test123 for user root in local machine is running
. Build, Test and Run the application locally
+

[source,java]
---------------------------------------------------------------------
./gradlew clean
./gradlew build
./gradlew bootRun
---------------------------------------------------------------------

. Stop the application. As we have to now prepare the application to be used in kubernetes cluster replace the following values in the application.properties in src/main folder
+

[source,java]
---------------------------------------------------------------------
spring.datasource.url=jdbc:mysql://mysql/pages?createDatabaseIfNotExist=true&allowPublicKeyRetrieval=true&useSSL=false
spring.datasource.username=root
spring.datasource.password=test123
---------------------------------------------------------------------


. Add the following in test.environment closure in build.gradle
+

[source,java]
---------------------------------------------------------------------
"SPRING_DATASOURCE_URL": "jdbc:mysql://localhost:3306/pages?createDatabaseIfNotExist=true&useSSL=false",
"SPRING_DATASOURCE_USERNAME": "root",
"SPRING_DATASOURCE_PASSWORD": "test123",
---------------------------------------------------------------------




. Build the application using the following command
+

[source,java]
---------------------------------------------------------------------
./gradlew clean
./gradlew build
---------------------------------------------------------------------


. Make change in the pages-deployment.yaml and pipeline.yaml to update the tag as persist
. build the docker image and tag it as persist ad push it to your docker hub repo.
. Point the kubectl context to minikube and run the following commands.
[source,java]
---------------------------------------------------------------------
kubectl apply -f deployment/pages-namespace.yaml
kubectl apply -f deployment/mysql-pv.yaml
kubectl apply -f deployment/mysql-secret.yaml
kubectl apply -f deployment/mysql-deployment.yaml
kubectl apply -f deployment/pages-config.yaml
kubectl apply -f deployment/pages-service.yaml
kubectl delete -f deployment/pages-deployment.yaml
kubectl apply -f deployment/pages-deployment.yaml
---------------------------------------------------------------------
. Test the application in minikube and see if the data is getting populated in mysql db.
. Point the kubectl context to aks cluster and apply the yamls. Make sure pages service on AKS is using LoadBalancer.
[source,java]
----------------------------------------------------------------
kubectl apply -f deployment/mysql-pv.yaml
kubectl apply -f deployment/mysql-secret.yaml
kubectl apply -f deployment/mysql-deployment.yaml
kubectl delete -f deployment/pages-deployment.yaml
kubectl apply -f deployment/pages-deployment.yaml
----------------------------------------------------------------

. Finally push the code to the github 

. Use the below command to set default namespace

+

[source,java]
---------------------------------------------------------------------
kubectl config set-context --current --namespace=<your-name>
---------------------------------------------------------------------


. Use the below command to connect to the mysql server and verify the schema and table
+

[source,java]
---------------------------------------------------------------------
kubectl run -it --rm --image=mysql:8.0 --restart=Never mysql-client -- mysql -h mysql -ppassword
---------------------------------------------------------------------
. Finally verify the url of the services and open the url on browser as per the instructions in the earlier labs to test the application.
